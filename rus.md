# Искусство Node

## Введение в Node.js

Этот документ предназначен для читателей, хотя бы немного знакомых со следующим:

* языком программирования, таким как JavaScript, Ruby, Python, Perl, и т.д. Если 
вы пока не являетесь программистом, наверное проще будет начать с чтения 
[«JavaScript для котиков»][1].
* git и github. Это инструменты для совместной роботы с открытым кодом, которые 
широко используются членами сообщества пользователей Node для обмена модулями. 
Вам нужно освоить только азы. Вот три отличных самоучителя для ознакомления: 
[1][2], [2][3], [3][4]

Написание этой короткой книги всё еще в процессе. Если хотите, пожалуйста 
**пожертвуйте доллар-два** через [gittip][5] чтобы я мог оправдать время, 
выделенное на написание продолжения!

## Содержание

* [Учим Node в интерактивном режиме](#--1)
* [Философия Node](#--2)
* [Базовые модули](#--3)
* [Функции обратного вызова](#--4)
* [События](#--5)
* [Потоки](#--6)
* [Модули и пакетный менеджер Node](#--7)
* [Разработка на стороне клиента с использованием пакетного менеджера Node](#--8)
* [Не будем идти против природы](#--9)

<a id="--1"></a>
## Учим Node в интерактивном режиме

Исключительно важно не просто почитать это руководство, но также вытащить ваш 
любимый текстовый редактор и, собственно, попробовать написать пару строчек кода 
Node. Я не раз уже отмечал про себя, что информация о коде, прочитанная в книге, 
редко откладывается в голове, а вот изучение посредством написания кода является 
хорошим подходом к освоению новых концепций программирования. 

### NodeSchool.io

[NodeSchool.io][6] — это подборка интерактивных мастер-классов, кстати 
бесплатных + с открытым кодом, в которых изложены принципы Node.js и не только.

[Мы научим вас Node.js][7] — это вводный мастер-класс от NodeSchool.io. В нём 
собрано описание проблем программирования, которое поможет вам ознакомиться с 
наиболее простыми шаблонами Node. Он доступен в виде консольной программы.

![программа learnyounode][программа learnyounode]

Её можно установить с помощью пакетного менеджера Node:

    # install
    npm install learnyounode -g

    # start the menu
    learnyounode

<a id="--2"></a>
## Философия Node

Node.js — это проект с открытым исходным кодом, разработанный для того, чтобы 
помочь нам с написанием программ на JavaScript, которые могли бы 
взаимодействовать с сетями, файловыми системами или другими I/O источниками 
(т.е. источниками ввода/вывода, чтения/произведения). Вот и всё! Это простая и 
стабильная I/O платформа, на которой рекомендуется строить модули. 

Какими бывают источники I/O? Вот схема приложения, построенного мной на Node, 
которая отображает их разнообразие:

![серверная схема][серверная схема]

Ничего страшного если вы понимаете не все надписи в схеме. Её смысл в том, чтобы 
показать, что один-единственный процесс Node (шестигранник в центре) может 
служить посредником между различными конечными точками (оранжевые и фиолетовые 
линии представляют ввод/вывод).

Обычно создание таких систем предусматривает одно из двух:
* сложный код, но с супер-быстрым результатом (как в случае с написанием 
веб-сервера с ноля на С)
* простой код, однако не слишком быстрый/устойчивый результат (как в случае, 
когда кто-нибудь пытается загрузить файл на 5Гб и сервер падает)

Цель Node состоит в достижении золотой середины между этими двумя вариантами: 
относительная простота в понимании и использовании в сочетании со скоростью 
работы в большинстве случаев применения.

Node не является:

* Веб-фреймворком (вроде Rails или Django, хотя его можно использовать для 
создания таких вещей)
* Языком программирования (для него используется JavaScript, Node не является 
языком сам по себе)

Node — это нечто среднее. Он:

* Создан чтобы быть простым и, следовательно, относительно лёгким в понимании и 
использовании
* Подходит для программ, предусматривающих операции ввода/вывода, которые должны 
быть быстрыми и выдерживать большое количество соединений

На более низком уровне Node можно описать как инструмент для написания программ 
двух типов:

* Сетевых программ, использующих веб-протоколы: HTTP, TCP, UDP, DNS и SSL
* Программ, производящих чтение и запись данных в/из файловых систем или 
локальных процессов/памяти.

Что следует понимать под «программами, предусматривающими операции ввода/вывода»? 
Вот некоторые наиболее типичные I/O источники:

* Базы данных (напр. MySQL, PostgreSQL, MongoDB, Redis, CouchDB)
* API (напр. Twitter, Facebook, рush-уведомления Apple)
* Соединения HTTP/WebSocket (от пользователей веб-приложения)
* Файлы (редактор изображений и видео, интернет-радио)

Node выполняет операции ввода/вывода [асинхронно][8], что позволяет ему 
проводить большое количество операций одновременно. Предположим, вы зашли в 
заведение быстрого питания и заказали чизбургер, вы делаете свой заказ и 
околачиваетесь поблизости пока его не приготовят. В то же время персонал может 
принимать заказы и готовить чизбургеры для других клиентов. Представьте что было 
бы если бы вы остались ждать свой чизбургер у кассы, не давая остальным 
посетителям в очереди сделать свой заказ до тех пор, пока ваш чизбургер не 
будет готов! Это называется **блокирующим вводом-выводом**, так как все операции 
ввода-вывода (приготовление чизбургеров) выполняются поочередно. Node, напротив, 
является **неблокирующим**, то есть может готовить много чизбургеров 
одновременно.

Вот несколько занимательных вещей, которые значительно упростились благодаря его 
неблокирующей сущности:

* Управление [летающими квадрокоптерами][9]
* Написание IRC-ботов
* Создание [двуногих роботов, способных ходить][10]

<a id="--3"></a>
## Базовые модули

Прежде всего я советовал бы вам установить Node на ваш компьютер. Проще всего 
это можно сделать, посетив [nodejs.org][11] и нажав `Install`. 

У Node есть небольшая базовая группа модулей (их принято называть «ядро Node»), 
представленных как открытые API, на основе которых следует писать программы. Для 
работы с файловыми системами существует модуль `fs`, для сетей используются 
такие модули как `net` (TCP), `http`, `dgram` (UDP).

В добавок к модулю `fs` и сетевым модулям, ядро Node содержит ряд других базовых 
модулей. Есть модуль для асинхронной обработки DNS-запросов под названием `dns`, 
модуль `os` для получения сведений об ОС, например о расположении tmpdir, модуль 
`buffer` для распределения бинарных участков памяти, несколько модулей для 
анализа ссылок и путей (`url`, `querystring`, `path`) и т.д. Большинство, если 
не все, модулей составляющих ядро Node, предназначены для обеспечения главного 
предназначения Node: написания быстрых программ, взаимодействующих с файловыми 
системами или сетями.

Node выполняет операции ввода-вывода с помощью: функций обратного вызова, 
событий, потоков и модулей. Если вы разберётесь с тем как работают эти четыре 
компонента, вы сможете взять любой модуль из ядра Node и более-менее чётко 
определить как его можно подключить куда-либо.

<a id="--4"></a>
## Функции обратного вызова

Если вы хотите понять как использовать Node, то с этой темой разобраться нужно 
прежде всего. Функции обратного вызова в Node используются практически 
повсеместно. Они не были придуманы под Node, а являются всего лишь частью языка 
JavaScript.

Функции обратного вызова — это функции, которые выполняются асинхронно, или же в 
отложенный момент времени. Вместо того чтобы методично считывать код сверху вниз, 
асинхронные программы могут выполнять различные функции в различное время, 
исходя из порядка и скорости предыдущих функций вроде http-запросов или 
считывания файловой системы.

Разница может быть непонятной, так как определить является функция асинхронной 
или нет можно большей мерой в зависимости от контекста. Вот простой пример 
синхронной функции, т.е. код можно читать сверху вниз как книгу: 

    var myNumber = 1
    function addOne() { myNumber++ } // определение функции
    addOne() // выполнение функции
    console.log(myNumber) // в консоль выводится 2

В этом коде идёт сначала определение функции, а затем в следующей строке её 
вызов, без каких-либо отсрочек. Когда происходит вызов функции, она немедленно 
приплюсовывает 1 к числу, так что можно рассчитывать что после вызова функции 
число должно быть 2. Это то, чего можно ожидать от синхронного кода — он 
последовательно выполняется сверху вниз. 

Однако, Node в большинстве своем использует асинхронный код. Попробуем считать 
число из файла под названием `number.txt`, используя Node: 

    var fs = require('fs') // require является специальной функцией предусмотренной в Node
    var myNumber = undefined // мы пока не знаем каким является число, так как оно хранится в файле

    function addOne() {
      fs.readFile('number.txt', function doneReading(err, fileContents) {
        myNumber = parseInt(fileContents)
        myNumber++
      })
    }

    addOne()

    console.log(myNumber) // в консоль выводится undefined -- эта строчка запускается перед выполнением readFile 

Почему в этот раз при выводе результата в консоль мы видим `undefined`? В этом 
коде мы используем метод `fs.readFile`, который является асинхронным. Обычно все 
взаимодействия с жёстким диском или сетью являются асинхронными. Если требуется 
всего лишь получение доступа к памяти или выполнение каких-либо действий с 
процессором, можно использовать синхронный подход. Причиной этому является то, 
что операции ввода-вывода ооооочень и оооочень меееедленные. По приблизительным 
оценкам, взаимодействие с жёстким диском занимает примерно в 100,000 раз больше 
времени чем взаимодействие с памятью (напр. с оперативной памятью).

При запуске этой программы все функции объявляются немедленно, но не все 
выполняются сразу же. Это то, что нужно чётко понять об асинхронном 
программировании. Когда происходит вызов `addOne`, она вводит `readFile` и 
переходит дальше к тому что может быть выполнено. Если выполнять нечего, Node 
либо ждёт на окончание текущих операций с файловыми системами/сетями или же 
прекращает работу и выходит в командную строку. 

Когда `readFile` заканчивает чтение файла (это может продолжаться от 
миллисекунды до нескольких секунд или минут в зависимости от скорости жесткого 
диска), он запускает функцию `doneReading` и передает ей ошибку (если она имела 
место) и содержимое файла. 

Выше мы получили `undefined` потому, что нигде в коде не прописано, что команда 
`console.log` должна подождать с выведением числа пока не закончит работу 
команда `readFile`.

Если вы хотите чтобы определённый код выполнялся снова и снова, или же в 
конкретный отсроченный момент, первым делом его следует поместить в функцию. 
Затем эту функцию можно будет вызвать в любое время, когда вы захотите чтобы ваш 
код выполнился. Удобнее давать функциям осмысленные названия, говорящие об их 
предназначении.

Функции обратного вызова — это функции, которые могут быть выполнены в более 
позднее время. Ключом к пониманию функций обратного вызова является осознание 
того, что они используются когда время окончания какой-либо асинхронной операции 
неизвестно, однако известно место её окончания — последняя строчка асинхронной 
функции! Порядок сверху-вниз, в котором объявлены функции не играет особого 
значения, в отличие от их логической/иерархичной вложенности. Сначала вы 
разбиваете код на функции, а затем используете функции обратного вызова для 
объявления зависимости одной функции от окончания другой. 

Метод `fs.readFile` придуман специально для Node, он является асинхронным и 
иногда его выполнение затягивается на длительное время. Вот что он делает: 
обращается к операционной системе, которая в свою очередь обращается к файловой 
системе, которая живёт на жёстком диске, вращающемся со скоростью выше или ниже 
тысячи оборотов в минуту. Затем с помощью лазера считываются данные и отсылаются 
назад тем же путём к программе javascript. Вы передаёте `readFile` функцию 
(известную как функция обратного вызова), которую он вызовет после получения 
данных из файловой системы. Он помещает полученные данные в переменную 
javascript и вызывает вашу функцию обратного вызова с этой переменной. В этом 
случае переменная носит название `fileContents`, так как в неё помещено 
содержимое прочитанного файла.

Вспомните пример с рестораном, приведённый в начале этого руководства. В 
большинстве таких заведений вы получаете номерок, который нужно положить на ваш 
столик пока вы ожидаете свой заказ. Это очень напоминает функции обратного 
вызова. Они говорят серверу что следует делать когда ваш чизбургер готов.

Давайте поместим нашу команду `console.log` в функцию и добавим её в код в 
качестве функции обратного вызова.

    var fs = require('fs')
    var myNumber = undefined

    function addOne(callback) {
      fs.readFile('number.txt', function doneReading(err, fileContents) {
        myNumber = parseInt(fileContents)
        myNumber++
        callback()
      })
    }

    function logMyNumber() {
      console.log(myNumber)
    }

    addOne(logMyNumber)

Теперь функции `logMyNumber` можно передать аргумент, который станет переменной 
`callback` внутри функции `addOne`. После завершения работы `readFile` будет 
вызвана переменная `callback` (`callback()`). Так как вызываться могут только 
функции, если попробовать вызвать что-либо кроме функции, получим ошибку.

Когда в javascript происходит вызов функции, код внутри этой функции немедленно 
выполняется. В этом случае команда вывода в консоль будет выполнена, поскольку 
`callback` по сути является `logMyNumber`. Помните, что если просто *объявить* 
функцию, это не значит, что она будет выполнена. Для этого нужно *вызвать* 
функцию.

Чтобы проанализировать этот пример еще подробней, рассмотрим хронометраж событий, 
которые происходят при выполнении этой программы:

1. Код анализируется, следовательно, если присутствуют синтаксические ошибки, 
программа работать не будет. На этом начальном этапе объявляются четыре 
компонента: `fs`, `myNumber`, `addOne` и `logMyNumber`. Обратите внимание, что 
происходит только их объявление, вызов каких-либо функций пока не производится.
2. При выполнении последней строчки нашей программы, вызывается `addOne`, 
которая передается функции `logMyNumber` в качестве `callback`, которую нам 
нужно вызвать после завершения `addOne`. Это немедленно запускает асинхронную 
функцию `fs.readFile`. Эта часть программы занимает много времени.
3. Так как больше ему заняться нечем, Node пребывает в режиме ожидания пока не 
завершится работа `readFile`. Если бы какие-либо задачи требовали выполнения в 
этот промежуток времени, Node занялся бы их выполнением.
4. `readFile` заканчивает работу и вызывает свою функцию обратного вызова 
`doneReading`, которая в свою очередь увеличивает число и немедленно вызывает 
функцию, введённую `addOne` (её функцию обратного вызова), `logMyNumber`.

Наверное больше всего сбивает с толку то, что с функциями можно обращаться как с 
простыми объектами, хранить их в переменных и передавать туда-сюда под разными 
именами. Чтобы ваш код мог прочитать кто-нибудь кроме вас, важно давать 
переменным простые и наглядные названия. В общем, если вы видите в программе на 
Node переменную вроде `callback` или `cb`, можете предположить что это функция.

Возможно вы слышали термины «событийно-ориентированное программирование» или 
«событийный цикл». Они описывают то, как выполняется `readFile`. Сначала Node 
запускает операцию `readFile` и затем ждёт пока `readFile` вышлет ему событие, 
символизирующее её завершение. В процессе ожидания Node может проверить 
состояние других процессов. У Node есть список операций, которые были запущены, 
но от которых пока не получен отчёт, он перебирает их снова и снова, проверяя не 
были ли они завершены. После окончания работы они «подвергаются обработке», 
например, происходит запуск функций обратного вызова, привязанных к завершению 
их работы. 

Вот схематическая версия кода, иллюстрирующая приведенный выше пример:

    function addOne(thenRunThisFunction) {
      waitAMinute(function waitedAMinute() {
        thenRunThisFunction()
      })
    }

    addOne(function thisGetsRunAfterAddOneFinishes() {})

Представьте, что у вас есть три асинхронные функции `a`, `b` и `c`. Выполнение 
каждой из них занимает минуту и после завершения каждой происходит запуск 
функции обратного вызова (которой передается первый аргумент). Если вы хотите 
сказать Node «запусти `a`, после её завершения выполни `b`, после завершения `b` 
запусти `c`» это выглядело бы так:

    a(function() {
      b(function() {
        c()
      })
    })

При выполнении этого кода, немедленно запустится `a`, через минуту она закончит 
работу и вызовет `b`, которая закончится еще через минуту и вызовет `c`, и 
наконец 3 минуты спустя после начала выполнения Node завершит обработку кода, 
так как больше задач не останется. Конечно же, можно было придумать более 
изящный способ для написания этого примера, однако смысл в том, что если у вас
есть код, который должен подождать пока не будет завершено выполнение другого 
асинхронного кода, то эту зависимость следует выразить поместив код в функции, 
которые передаются как функции обратного вызова.

Структура Node требует от разработчика нелинейного мышления. Взгляните на этот 
список операций:

    чтение файла
    обработка файла

Если бы вам пришлось превратить его в код, у вас получилось бы следующее:

    var file = readFile()
    processFile(file)

Такой линейный (пошаговый, упорядоченный) код не соответствует тому, как 
работает Node. Если начать обработку такого кода, `readFile` и `processFile` 
выполнялись бы одновременно. Это бессмысленно, так как выполнение `readFile` 
займет много времени. Вместо этого вам нужно выразить что `processFile` должна 
быть запущена после завершения `readFile`. Именно для этого и существуют функции 
обратного вызова! Благодаря особенностям JavaScript, эту зависимость можно 
прописать в несколько разных способов:

    var fs = require('fs')
    fs.readFile('movie.mp4', finishedReading)

    function finishedReading(error, movieData) {
      if (error) return console.error(error)
      // проведение действий с movieData
    }

Однако можно прописать и такую структуру кода и он все так же будет работать:

    var fs = require('fs')

    function finishedReading(error, movieData) {
      if (error) return console.error(error)
      // проведение действий с movieData
    }

    fs.readFile('movie.mp4', finishedReading)

Или даже так:

    var fs = require('fs')

    fs.readFile('movie.mp4', function finishedReading(error, movieData) {
      if (error) return console.error(error)
      // проведение действий с movieData
    })

<a id="--5"></a>
## События

В Node если вам нужен модуль событий, можете воспользоваться так называемым 
«генератором событий», который используется во всех его API, которые что-либо 
генерируют.

События, более известные как [шаблон «наблюдатель»][13] или «издатель-подписчик», 
являются широко распространённым шаблоном в программировании. В то время, как 
функции обратного вызова представляют собой индивидуальную связь между тем, что
ожидает на функцию обратного вызова и тем, что вызывает эту функцию, события 
представляют собою такую же связь только между многими API.

Проще всего представить себе принцип работы событий как подписку на нечто. Они 
позволяют указать «когда Х, сделай Y», тогда как простые функции обратного 
вызова указывают только «сделай Х, затем Y».

Вот несколько типичных случаев использования событий вместо обычных функций 
обратного вызова:

* Чат, в котором вы хотите транслировать сообщения для многих пользователей
* Игровой сервер, которому нужно знать когда новые игроки подсоединяются, 
отсоединяются, двигаются, стреляют и прыгают
* Игровой движок в котором вы хотите предусмотреть для разработчиков игры 
возможность подписываться на события вроде `.on('jump', function() {})`
* Веб-сервер низкого уровня, на котором нужно предоставить API для простого 
подключения к происходящим событиям вроде `.on('incomingRequest')` или 
`.on('serverError')`

Если бы мы попробовали написать модуль, подключающийся к серверу чата, используя 
только функции обратного вызова, он бы выглядел так:

    var chatClient = require('my-chat-client')

    function onConnect() {
      // подтверждение подключения в интерфейсе
    }

    function onConnectionError(error) {
      // уведомление пользователя об ошибке 
    }

    function onDisconnect() {
     // уведомление пользователя об отключении 
    }

    function onMessage(message) {
     // отображение в интерфейсе сообщения из чата 
    }

    chatClient.connect(
      'http://mychatserver.com',
      onConnect,
      onConnectionError,
      onDisconnect,
      onMessage
    )

Как видите, такой способ очень громоздкий, так как функции `.connect` нужно 
передать большое количество функций в определённом порядке. Написание того же с 
использованием событий выглядело бы так:

    var chatClient = require('my-chat-client').connect()

    chatClient.on('connect', function() {
      // подтверждение подключения в интерфейсе
    }) 

    chatClient.on('connectionError', function() {
      // уведомление пользователя об ошибке 
    })

    chatClient.on('disconnect', function() {
      // уведомление пользователя об отключении 
    })

    chatClient.on('message', function() {
      // отображение в интерфейсе сообщения из чата
    })

Этот подход похож на подход с использованием одних лишь функций обратного вызова, 
однако добавлен метод `.on`, который подписывает функцию обратного вызова на 
событие. Это значит, что вы можете выбирать на какие события в `chatClient` 
нужно подписаться. Также можно подписаться на одно и то же событие несколько раз, 
используя разные функции обратного вызова:

    var chatClient = require('my-chat-client').connect()
    chatClient.on('message', logMessage)
    chatClient.on('message', storeMessage)

    function logMessage(message) {
      console.log(message)
    }

    function storeMessage(message) {
      myDatabase.save(message)
    }

<a id="--6"></a>
## Потоки

На начальной стадии существования проекта Node для файловых систем и сетевых API 
использовались разные подходы к обработке потоковых операций ввода-вывода. 
Например, для файлов в файловых системах применялись так называемые «файловые 
дескрипторы», соответственно модуль `fs` был наделён дополнительной логикой, 
позволяющей их отслеживать, в то время, как для сетевых модулей такая концепция 
не использовалась. Несмотря на подобные незначительные различия в семантике, на 
более глубоком уровне считывания и вывода данных, у обеих групп кода большая 
часть функционального наполнения дублировалась. Команда разработчиков Node 
поняла, что не стоит всё усложнять необходимостью изучать два набора 
семантических правил для выполнения практически одного и то же и разработала 
новый API под названием `Stream` для всего кода сетей и файловых систем. 

Весь замысел Node состоит в упрощении работы с файловыми системами и сетями, 
поэтому вполне разумно во всех случаях использовать общий шаблон. Хорошая 
новость состоит в том, что большинство таких шаблонов (их всего несколько) на 
данный момент уже разработаны и вероятность того, что со временем Node сильно 
изменится, ничтожна.

Для изучения потоков Node есть два отличных ресурса. Один из них — 
stream-adventure, второй — справочный ресурс под названием «Справочник по 
потокам».

### Справочник по потокам

[Справочник по потокам][14] — это руководство, похожее на текущее, которое 
содержит ссылки на всё, что вам следует знать о потоках.

![stream-handbook][stream-handbook]

<a id="--7"></a>
## Модули

Ядро Node состоит приблизительно из двух дюжин модулей, некоторые из них более 
низкого уровня, такие как `events` и `stream`, другие — более высокого, такие 
как `http` и `crypto`.

Такая структура была придумана специально. Ядро Node должно быть небольшим, а 
модули, его составляющие, должны являться кросс-платформенными инструментами для 
работы со всеми распространёнными протоколами и форматами ввода-вывода.

Для всего остального существует [пакетный менеджер Node][15]. Кто угодно может 
создать новый модуль Nodе с дополнительными функциональными возможностями и 
добавить его в пакетный менеджер. На время написания этой статьи он насчитывает 
34,000 модулей.

### Как найти модуль

Представьте, что вам нужно переконвертировать файлы PDF в TXT. Начать лучше 
всего с команды `npm search pdf`:

![поиск pdf][поиск pdf]

Результатов масса! Пакетный менеджер довольно популярен и в большинстве случаев 
вы сможете найти несколько потенциальных решений. Если пройтись по модулям и 
сократить количество результатов (отфильтровав результаты вроде модулей 
генерирования PDF), получим следующие:

* [hummus][16] — модуль управления pdf на с++
* [mimeograph][17] — api на основе совмещения инструментов (poppler, tesseract, 
imagemagick и др.)
* [pdftotextjs][18] — оболочка для утилиты [pdftotext][19]
* [pdf-text-extract][20] — ещё одна оболочка для pdftotext
* [pdf-extract][21] — оболочка для pdftotext, pdftk, tesseract, ghostscript
* [pdfutils][22] — оболочка для библиотеки poppler
* [scissors][23] — оболочка для pdftk, ghostscript с api высокого уровня
* [textract][24] — оболочка для pdftotext 
* [pdfiijs][25] — конвертер pdf в инвертированный индекс с использованием 
textiijs и poppler
* [pdf2json][26] — конвертер pdf в json на чистом js

Функциональные возможности многих модулей пересекаются, однако представляют 
альтернативные API и большинство из них требует установку внешних зависимостей 
(таких как `apt-get install poppler`).

Вот примеры толкования модулей:

* `pdf2json` является единственным написанным на чистом JavaScript, что делает 
его самым простым в установке, особенно на маломощных устройствах вроде 
одноплатного компьютера Raspberry Pi или на Windows, где внутренний код может не 
быть кроссплатформенным.
* каждый из модулей вроде `mimeograph`, `hummus` и `pdf-extract` объединяют в 
себе несколько модулей низшего уровня для предоставления высокоуровневого API
* множество модулей является надстройками для `pdftotext`/`poppler`, консольных 
инструментов unix

Давайте сравним `pdftotextjs` и `pdf-text-extract`, оба из которых являются 
оболочками для утилиты `pdftotext`.

![pdf-модули][pdf-модули]

Оба эти модуля:

* были обновлены сравнительно недавно
* имеют собственные репозитории на github (это очень важно!)
* имеют описания `README`
* еженедельно устанавливаются некоторым количеством пользователей
* имеют достаточно свободную лицензию (кто-угодно может их использовать)

Всего лишь взглянув на `package.json` + статистику модуля, трудно понять какой 
из них лучше выбрать. Давайте сравним описания в README:

![pdf-описания][pdf-описания]

У обеих простые описания, указан статус сборки, есть инструкции по установке, 
понятные примеры и инструкции для проведения тестирования. Отлично! Однако какой 
выбрать? Давайте сравним код:

![pdf-код][pdf-код]

`pdftotextjs` состоит из около 110 строчек кода, а `pdf-text-extract` — из 40, 
однако по сути оба сводятся к следующей строчке:

    var child = shell.exec('pdftotext ' + self.options.additional.join(' '));

Делает ли это один из них лучше другого? Трудно сказать. Важно собственно 
*вчитаться* в код и сделать свое собственное заключение. Когда встречаете 
понравившиеся вам модули, используйте `npm star modulename`, чтобы оставить в 
пакетном менеджере свой отзыв о модулях, от работы с которыми получили приятные 
впечатления.

### Организация процесса разработки с использованием модулей

Пакетный менеджер Node отличается от большинства пакетных менеджеров тем, что 
устанавливает модули в папку внутри других существующих модулей. Предыдущее 
предложение может сейчас показаться бессмыслицей, однако оно является ключевым в 
успешности пакетного менеджера Node.

Многие пакетные менеджеры устанавливают всё глобально. Например, если задать 
команду `apt-get install couchdb` в Debian Linux, она попытается установить 
последнюю стабильную версию CouchDB. Если вы хотите установить CouchDB как 
зависимость для другой программы и эта программа требует более раннюю версию 
CouchDB, вам придётся деинсталлировать более новую версию CouchDB и затем 
установить более старую. Установить обе версии нельзя, так как Debian умеет 
устанавливать что-либо только в одном месте. 

Так обстоят дела не только в Debian. Точно так же работает большинство пакетных 
менеджеров для различных языков программирования. Чтобы решить проблему с 
глобальной установкой зависимостей, описанную выше, было разработано виртуальное 
окружение, такое как [virtualenv][27] для Python и [bundler][28] для Ruby. Они 
разбивают ваше окружение на множество виртуальных, по одному на каждый проект, 
однако внутри виртуального окружения зависимости устанавливаются всё так же 
глобально. Виртуальные окружения не всегда решают проблему, иногда они её 
приумножают, добавляя новые наслоения сложностей.

При использовании пакетного менеджера Node, устанавливать глобальные модули 
крайне не рекомендуется. Точно так же как в программах на JavaScript не 
рекомендуется использовать глобальные переменные, так же и с установкой 
глобальных модулей (разве что вам нужно чтобы модуль с загрузочным двоичным 
кодом отображался в глобальном `PATH`, однако это требуется не всегда -- больше 
об этом попозже).

#### Как работает `require`

Когда вы вызываете `require('some_module')` в Node, вот что происходит:

1. Если в текущей папке есть файл с названием `some_module.js`, Node его 
загрузит, в противном случае:
2. Node проверит текущую папку на наличие папки `node_modules` с папкой 
`some_module` внутри неё
3. Если он её не найдет, он возвращается на одну папку выше и повторяет шаг 2

Этот цикл повторяется, пока Node не достигнет корневой папки файловой системы, 
после чего он проверит наличие папок с глобальными модулями (например, 
`/usr/local/node_modules` на Mac OS) и если `some_module` опять не будет найден,
он сгенерирует исключение.

Вот визуальный пример:

![модули-01][модули-01]

Когда текущей рабочей директорией является `subsubfolder` и происходит вызов 
`require('foo')`, Node ищет папку с названием `subsubsubfolder/node_modules`. В 
этом случае он её не найдет, так как папка по ошибке названа `my_modules`. Затем 
Node поднимается на одну папку выше и повторяет попытку, то есть он ищет 
`subfolder_B/node_modules`, которая также не существует. Третья попытка тем не 
менее оказывается удачной, поскольку `folder/node_modules` существует и содержит 
папку с названием `foo` внутри. Если бы `foo` в ней не было, Node продолжил бы 
поиск вверх по дереву директорий.

Обратите внимание, что если бы Node был вызван в папке `subfolder_B`, он ни за 
что бы не нашел `subfolder_A/node_modules`, так как он может увидеть 
`folder/node_modules` только по пути вверх по дереву директорий.

Одним из преимуществ подхода пакетного менеджера Node является то, что модули 
могут устанавливать зависимые модули конкретных рабочих версий. В этом случае 
очень популярен модуль `foo` — он установлен трижды, по одному образцу в папке 
родительского модуля. Причиной этому может быть то, что для каждого 
родительского модуля требуется другая версия `foo`, например для `folder` нужен 
`foo@0.0.1`, для `subfolder_A` — `foo@0.2.1` и т.д.

Вот что произойдет, если исправить ошибку в названии папки с `my_modules` на 
более правильное `node_modules`:

![модули-02][модули-02]

Чтобы проверить, какой модуль собственно будет загружен Node, можно использовать 
команду `require.resolve('some_module')`, которая отобразит путь к модулю, 
найденному Node в процессе взбирания вверх по дереву директорий. 
`require.resolve` может пригодиться для перепроверки того, что будет загружен 
именно тот модуль, который вы ожидаете. Иногда оказывается, что существует ещё 
одна версия того же модуля ближе к текущей рабочей директории, чем тот, который 
вы хотели бы загрузить.

### Как написать модуль

Теперь, когда вы знаете как искать модули и делать на них запрос, можно 
приступать к написанию собственных модулей.

#### Наипростейший модуль из возможных

Модули Node исключительно мало весят. Вот один из наипростейших модулей:

`package.json`:

    {
      "name": "number-one",
      "version": "1.0.0"
    }

`index.js`:

    module.exports = 1

По умолчанию, Node пытается загрузить `module/index.js` когда вы вводите команду 
`require('module')`, никакое другое имя работать не будет если вы не пропишите 
путь к нему в `package.json` в поле `main`. 

Поместите оба файла в папку `number-one` (`id` в `package.json` должно 
соответствовать названию папки) и получите работающий модуль Node.

Вызов функции `require('number-one')` возвращает то значение, которое указано 
для `module.exports` внутри модуля:

![простой модуль][простой модуль]

Еще быстрее создать модуль можно с помощью этих команд:

    mkdir my_module
    cd my_module
    git init
    git remote add git@github.com:yourusername/my_module.git
    npm init

Выполнение `npm init` создаст работающий `package.json` и, если вы запустите его 
в существующем репозитории `git`, он также автоматически добавит в `package.json` 
поле `repositories`!

#### Добавление зависимостей

Модуль может содержать перечень каких-либо других модулей из пакетного менеджера 
или GitHub в поле `dependencies` в `package.json`. Чтобы установить модуль 
`request` как новую зависимость и автоматически добавить его в `package.json`, 
выполните эту команду из корневой директории вашего модуля:

    npm install --save request

Это установит образец `request` в ближайшую папку `node_modules` и даст нам 
`package.json` в примерно следующем виде:

    {
      "id": "number-one",
      "version": "1.0.0",
      "dependencies": {
        "request": "~2.22.0"
      }
    }

По умолчанию, `npm install` установит последнюю официальную версию модуля.

<a id="--8"></a>
## Разработка на стороне клиента с использованием пакетного менеджера Node

Популярным является заблуждение, что поскольку в названии Пакетного менеджера 
Node указано слово «Node» (рус. — узел, ), он должен использоваться только для 
JS модулей на стороне сервера. Это абсолютно не так! Название пакетного 
менеджера Node подразумевает, что он отвечает за управление модулями, которые 
Node упаковывает для вас в пакеты. Модули сами по себе могут быть какими угодно — 
они всего лишь представляют из себя папку с файлами, упакованную в архив .tar.gz, 
и файл `package.json`, в котором указана версия модуля и перечень модулей, 
являющихся его зависимостями (а также номера их версий, чтобы рабочие версии 
устанавливались автоматически). Зависимости модулей являются обычными модулями, 
которые тоже могут иметь зависимости и так до бесконечности.

[browserify][29] — это утилита, написанная на Node, которая пытается 
переконвертировать любой модуль Node так, чтобы он мог быть запущен в браузере. 
Не все (например, браузеры нельзя использовать для таких задач как хостинг 
HTTP-сервера), но многие модули действительно работают.

Чтобы попробовать как пакетный менеджер Node работает в браузере, используйте 
[RequireBin][30], приложение, созданное мной на основе [Browserify-CDN][31], в 
корень которого положен browserify, но для вывода используется HTTP (вместо 
командной строки, которая обычно используется для browserify).

Скопируйте этот код в RequireBin и нажмите кнопку предварительного просмотра:

    var reverse = require('ascii-art-reverse')

    // делает HTML консоль видимой
    require('console-log').show(true)

    var coolbear =
      "    ('-^-/')  \n" +
      "    `o__o' ]  \n" +
      "    (_Y_) _/  \n" +
      "  _..`--'-.`, \n" +
      " (__)_,--(__) \n" +
      "     7:   ; 1 \n" +
      "   _/,`-.-' : \n" +
      "  (_,)-~~(_,) \n"

    setInterval(function() { console.log(coolbear) }, 1000)

    setTimeout(function() {
      setInterval(function() { console.log(reverse(coolbear)) }, 1000)
    }, 500)

Или можете взглянуть на [более сложный пример][32](не стесняйтесь поиграть с 
кодом чтобы посмотреть что получится):

![requirebin][requirebin]

<a id="--9"></a>
## Не будем идти против природы

Как любой хороший инструмент, Node лучше всего приспособлен для ограниченного 
набора задач. Например, Rails, популярный веб-фреймворк, идеально подходит для 
сложной [бизнес-логики][33], т.е. использования кода для представления реальных 
бизнес объектов, вроде счетов, ссуд и оборотного капитала. Хотя создание вещей 
того же типа с помощью Node и является технически возможным, без изъянов не 
обойдётся, так как Node придуман для решения проблем ввода-вывода и не слишком 
подкован в сфере «бизнес-логики». Каждый инструмент предназначен для своей 
проблемы. Надеюсь это руководство поможет вам приобрести интуитивное понимание 
сильных сторон Node и того, в каких случаях он вам пригодится.

### Что не входит в компетенцию Node?

По большому счёту, Node — это всего лишь инструмент, используемый для управления 
операциями ввода-вывода в файловых системах и сетях, остальные навороченные 
функциональные возможности ложатся на посторонние модули. Вот некоторые вещи, 
выходящие за рамки компетенции Node:

#### Веб-фреймворки

Существует ряд веб-фреймворков, построенных на основе Node (под фреймворком 
следует понимать пакет решений, целью которого является решение некой 
высокоуровневой проблемы вроде моделирования бизнес-логики), однако Node 
веб-фреймворком не является. Веб-фреймворки, написанные с помощью Node, не 
всегда разделяют его подход к наращиванию многокомпонентности, абстрактности и 
компромиссности и могут иметь другие приоритеты.

#### Языковой синтаксис

Node использует JavaScript без каких-либо изменений. Феликс Гейзендорфер (Felix 
Geisendorfer) составил хорошее описание «стиля Node» [здесь][34].

#### Языковые абстракции

При любой возможности Node использует самый простой из доступных способов 
выполнить задачу. Чем навороченнее ваш JavaScript, тем больше сложностей и 
компромиссов вам приходится внедрять. Программирование — непростое занятие, 
особенно когда речь идёт о JS, у которого на каждую проблему по 1000 решений. 
Именно поэтому Node всегда пытается выбрать самое простое и универсальное из них. 
Если вы заняты проблемой, для которой требуется сложное решение и недовольны 
«простенькими решениями», которые применяет Node, вы можете без проблем решить 
её для своего приложения или модуля используя любые абстракции на ваш вкус.

Прекрасным примером этому служит использование в Node функций обратного вызова. 
Изначально в Node проводились эксперименты с элементом под названием «промисы», 
которые предусматривали ряд приспособлений для того, чтобы асинхронный код 
выглядел более линейным. Они были изъяты из ядра Node по нескольким причинам:

* Они более сложны, чем функции обратного вызова
* Они могут быть внедрены в пространстве пользователя (распространены в пакетном
менеджере Node как сторонние модули)

Рассмотрим самое простое и базовое действие, которое производит Node: чтение 
файла. В процессе чтения файла вы хотите знать когда происходят ошибки, например, 
когда жесткий диск глохнет в самый разгар считывания. Если бы промисы 
использовались в Node, дерево кода должно было бы выглядеть так:

    fs.readFile('movie.mp4')
      .then(function(data) {
        // проведение действий с данными
      })
      .error(function(error) {
        // обработка ошибки
      })

Это всё усложняет, что не каждому понравится. Вместо двух отдельных функций, 
Node использует одну-единственную функцию обратного вызова. Он следует таким 
правилам:

* если ошибка не произошла, `null` передаётся в качестве первого аргумента
* Когда происходит ошибка, она передаётся в качестве первого аргумента
* Остальными аргументами может быть что-угодно (обычно это данные или отклики, 
так как Node отвечает в основном за чтение или запись)

Отсюда стиль функций обратного вызова Node:

    fs.readFile('movie.mp4', function(err, data) {
      // обработка ошибки, выполнение действий с данными
    })

#### Потоки исполнения/волокна/достижение параллельности без использования событий

Примечание: Если эти названия ни о чём вам не говорят, возможно вам будет проще 
освоить Node, так как избавление от знаний требует столько же усилий сколько их 
получение. 

Node использует потоки исполнения для ускорения процессов, но не отображает их 
пользователю. Если вы технически подкованный пользователь, интересующийся почему 
Node был задуман именно таким образом, вам 100% следует почитать о [структуре 
библиотеки libuv][35], I/O-слое C++, на котором построен Node. 

[1]: http://jsforcats.com/
[2]: http://skli.se/2012/09/22/introduction-to-git/
[3]: http://zachbruggeman.me/github-for-cats/
[4]: http://opensourcerer.diy.org/
[5]: https://www.gittip.com/maxogden/
[6]: http://nodeschool.io/
[7]: https://github.com/rvagg/learnyounode#learn-you-the-nodejs-for-much-win
[8]: http://en.wikipedia.org/wiki/Asynchronous_I/O
[9]: http://nodecopter.com/
[10]: https://www.youtube.com/watch?v=jf-cEB3U2UQ
[11]: http://nodejs.org/
[12]: http://nodejs.org/api/events.html
[13]: http://en.wikipedia.org/wiki/Observer_pattern
[14]: https://github.com/substack/stream-handbook#introduction
[15]: https://www.npmjs.org/
[16]: https://github.com/galkahana/HummusJS/wiki/Features
[17]: https://github.com/steelThread/mimeograph
[18]: https://www.npmjs.org/package/pdftotextjs
[19]: https://en.wikipedia.org/wiki/Pdftotext
[20]: https://www.npmjs.org/package/pdf-text-extract
[21]: https://www.npmjs.org/package/pdf-extract
[22]: https://www.npmjs.org/package/pdfutils
[23]: https://www.npmjs.org/package/scissors
[24]: https://www.npmjs.org/package/textract
[25]: https://github.com/fagbokforlaget/pdfiijs
[26]: https://github.com/modesty/pdf2json/blob/master/readme.md
[27]: http://docs.python-guide.org/en/latest/dev/virtualenvs.html
[28]: http://bundler.io/
[29]: http://browserify.org/
[30]: http://requirebin.com/
[31]: https://github.com/jesusabdullah/browserify-cdn
[32]: http://requirebin.com/?gist=6031068
[33]: http://en.wikipedia.org/wiki/Business_logic
[34]: https://github.com/felixge/node-style-guide
[35]: http://nikhilm.github.io/uvbook/

[программа learnyounode]: img/learnyounode.png
[серверная схема]: img/server-diagram-RU.png
[stream-handbook]: img/stream-handbook.png
[поиск pdf]: img/npm-search.png
[pdf-модули]: img/pdf-modules-ru.png
[pdf-описания]: img/pdf-readmes-ru.png
[pdf-код]: img/pdf-code.png
[модули-01]: img/mod-diagram-01.png
[модули-02]: img/mod-diagram-02.png
[простой модуль]: img/simple-module.png
[requirebin]: img/requirebin.png